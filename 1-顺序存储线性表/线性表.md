# 线性表

## 线性表（List）的表现形式

- 零个或多个数据元素的集合
- 数据元素是有序排列的
- 数据元素个数有限
- 数据类型必须相同

## 线性表的定义

- 具有形同类型的n（n >= 0）个数据元素的有限序列

    a0,a2......an-1 \
    ai是表项，n为数据长度

## 线性表的性质

- a0作为第一个元素，只有一个后继
- an-1作为最后一个元素，只有一个前驱
- 除了第一个和最后一个元素外，其余的元素既有前驱也有后继
- 直接支持逐项访问和顺序存储

## 下面中可以用线性表进行描述的是哪些？

- 班级之间同学的友谊关系（N，一对多）
- 公司中的上下级关系（N，一对多）
- 冬天图书馆用物品排队占座（N，类型不同）
- 花名册上名字之间的关系（Y）

## 在程序里面如何描述和使用线性表？

线性表的常用操作

- 插入
- 删除
- 读取
- 写入
- 清空
- 获取长度

线性表在程序中表现为一种特殊的数据类型

```c++
namespace DataStructure
{
    template <typename T> class List;
}

template <typename T>
class List
{
public:
    virtual bool insert(int i, const T &e) = 0;
    virtual bool remove(int i) = 0;
    virtual bool set(int i, const T &e) = 0;
    virtual bool get(int i, T &e)const = 0;
    virtual int  length(void) const = 0;
    virtual void clear(void) = 0;
};
```

线性表在C++里面就是一个抽象类

## 顺序存储的定义

线性表的顺序存储结构，指的是使用一片地址连续的存储空间依次存储线性表中的数据元素。

顺序结构的元素获取操作：

- 判断目标位置是否合法
- 将目标位置作为数组下标获取元素

顺序结构的元素插入:

- 判断目标位置是否合法
- 将目标位置之后所有元素后移动一位
- 将新元素插入目标位置
- 线性长度加一

顺序存储结构的删除操作:

- 判断位置是否合法
- 将该位置后所有元素向前移动一位
- 数据长度减去1

完成顺序结构线性表的抽象实现

- 抽象类模板，存储空间和大小由子类实现
- 实现顺序存储线性表的关键操作（增，删，查，改）
- 提供数组操作符，方便访问元素

StaticList设计要点：

- 类模板

  - 使用原生数组作为存储空间
  - 使用模板参数决定数组大小 

```c++
template <typename T, int N>
class StaticList:public SeqList<T>
{
protected:
    T m_space[N];
public:
    StaticList();
    int capacity() const;
};
```

DynamicList设计要点：

- 类模板

  - 申请连续存储空间作为顺序存储空间
  - 动态设置顺序存储空间的大小
  - 保证重置顺序存储孔家时的异常安全性

- 函数异常安全的概念

  - 不泄漏任何资源
  - 不允许破坏数据

- 函数异常安全的基本保证

  - 如果异常抛出
  - 对象内任何成员仍然能够保持有效状态
  - 没有数据破坏和资源泄漏

```c++
template <typename T>
class DynamicList:public SeqList<T>
{
protected:
    int m_capacity;
public:
    DynamicList(int capacity);
    int capacity() const;
    void resize(int capacity);
    ~DynamicList();
};
```

是否可以将DynamicList作为Static的子类实现？

- 不可以，内存分配方式不停

## 顺序存储线性表的效率分析

在涉及到效率的时候通常考虑最坏情况（插入和删除操作是线性表中最耗时的操作）

```c++
template <typename T>
class SeqList:public List<T>
{
protected:
    T * m_array;
    int m_length;

public:
    //O(n)
    bool insert(int i, const T &e);
    //O(n)
    bool remove(int i);
    //O(1)
    bool set(int i, const T &e);
    //O(1)
    bool get(int i, T &e)const;
    //O(1)
    int  length(void) const;
    //O(1)
    void clear(void);
    //O(1)
    T& operator[] (int i);
    //O(1)
    T operator[] (int i) const;
    //O(1)
    virtual  int capacity(void)const = 0;
};

// 不同类型之间的插入和删除所用时间不同
SeqList<int> S1;
SeqList<string> S2;
```

分析效率不能只看时间复杂度，还要根据具体场景考虑，基于顺序存储结构的线性表不适合类类型的数据存储。

## 下面的代码正确吗？为什么？

```c++
StaticList<int *, 5> s1;
StaticList<int *, 5> s2;

for(int i = 0; i < s1.capacity(); i++)
    s1.insert(0, new int(i));

s2 = s1;

for(int i = 0; i < s1.capacity(); i++)
{
    delete s1[i];
    delete s2[i];
}
```

不正确，因为s2=s1是浅拷贝，两个对象指向同一段空间，同一个空间被释放两次

```c++
DyanmicList<int> d1;
DyanmicList<int> d2 = d1;

for(int i = 0; i < d1.capacity(); i++)
{
    d1.insert(0, i);
    d2.insert(0, i*i);
}

delete d1[i];
delete d2[i];
```

不正确，拷贝构造将d2的m_array赋值为d1的m_array，并且同一段内存被释放两次

分析

- 对于容器类型的类，可以考虑禁用拷贝构造和赋值操作

```c++
int main()
{
    StaticList<int, 5> s1;
    for(int i = 0; i< s1.capacity(); i++)
    {
        s1[i] = i * i;
    }
    return 0;
}
```

不正确，线性表必须先插入元素才能使用[]访问
