# 链式存储线性表

## 顺序存储线性表最大的问题

- 插入和删除需要大量移动元素

链式存储的定义

- 为了表示每个元素和与其直接后继元素之间的关系，数据元素除了要存储本身的信息外，还需要存储其直接后继信息。

|......| ai | 地址0x80AB0C | ai+1 | 地址0x80FFD0 | ...... |
|------|----|-------------|------|--------------|--------|

ai和ai+1是线性表中两个相邻元素，但是在物理地址上不存在相邻关系

## 专业术语的统一

- 顺序表
  - 基于顺序存储结构的线性表
- 链表
  - 基于链式存储结构的线性表
  - 单链表：每个节点只包含后继信息
  - 循环链表：单链表的直接后继节点为第一个节点
  - 双向链表：每个节点包含直接前驱和后继的地址信息

## 链表中的基本概念

- 头节点
  - 链表中的辅助姐弟哪，包含执行第一个元素的指针
- 数据节点
  - 链表中代表数据元素的节点，表现形式为:(数据，地址)
- 尾节点
  - 链表中最后一个数据节点，包含的地址信息为空

## 单链表中的节点类型

```c++
struct Node
{
    T value;
    Node* next;
};
```

### 单链表中的内部结构

- 头节点->数据->NULL
- 头节点的意义在于：辅助数据元素定位，方便进行插入和删除操作，因此，头节点不存储数据

### 在目标位置插入数据元素

- 从头节点通过指针找到指定位置
- 从堆空间申请新的节点
- 执行操作：
  - 拷贝插入值到新申请的节点(node->value = e)
  - 将新申请的节点指针指向下一个节点(node->next = current->next)
  - 将当前位置的节点的指针指向新申请的节点(current->next = node)

### 在目标位置删除元素

- 从头节点通过指针找到指定位置
- 使用toDel指向要删除的节点
- 执行操作：
  - toDel = current->next;
  - current->next = toDel->next;
  - delete toDel;

### 问题

- 头节点是否存在隐患？
  - 泛指类型如下：
  - 头节点中包含了该自定义类型的一个变量，无参构造函数会抛出异常

```c++
  class Test
  {
    public:
    Test()
    {
        throw 0;
    }
  }
```

- 解决方法

```c++
struct Node
{
    T data;
    Node* next;
};
        
// 为了防止自定义类型无参构造函数抛出异常
mutable struct{
    char reserve[sizeof(T)];
    Node* next;
}m_head;
```

- 为了保证内存一致，两个结构体应该还需要注意一点，如果存在继承关系，需要继承自相同的父类

- 实现代码是否需要优化？
  - 在插入，删除，查找，设置过程中存在查找元素，所以可以单独作为一个函数。

### 代码修改之后需要重新来对代码进行测试

### 顺序表和链表的对比分析

问题：如何判断某个数据元素是否存在于线性表中？

- 遗失的操作-find
  - 可以为线性表(List)增加一个查找操作
  - int find(const T& e)const;
  - 返回值:
    - 大于0，对应元素的索引
    - -1，查找失败

问题：顺序表的整体时间复杂度比单链表的时间复杂度低，但是单链表使用更多，为什么？

- 效率的深度分析
  - 实际工程开发中，时间复杂度只是效率的一个参考
    - 对于内置基础类型，顺序表和单链表的效率不相上下
    - 对于自定义类型，顺序表效率低于单链表
  - 插入和删除
    - 顺序表：涉及大量数据的复制
    - 单链表：只涉及指针操作
  - 数据访问
    - 顺序表：随机访问，直接定位对象
    - 单链表：顺序访问，必须从头到尾，无法直接定位
- 工程中的选择
  - 顺序表
    - 数据元素相对简单，不涉及深拷贝
    - 数据元素相对稳定，访问操作多于插入和删除操作
  - 单链表
    - 数据元素的类型相对复杂，复制操作相对耗时
    - 数据元素不稳定，需要经常插入和删除，访问操作比较少

### 单链表中遍历与优化

```c++
DataStructure::LinkList<int> val;

// 从头部插入 O(n)
for(int i = 0; i < 5; i++)
{
    val.insert(i);
}

// O(n^2)
for(int i = 0; i < val.length(); i++)
{
    std::cout << val.get(i) << std::endl;
}
```

- 缺陷：
  - 不能以线性时间完成单链表单遍历
- 新的需求
  - 为单链表提供新的方法在线性时间内完成遍历
- 设计思路
  - 在单链表内部定义一个游标
  - 遍历开始前将游标指向第一个元素
  - 获取游标指向的数据元素
  - 通过节点的next指针移动游标
- 提供一组遍历相关的函数，以线性的时间复杂度完成遍历
  - move()将游标定位到目标位置
  - next()移动游标
  - current()获取游标指向的数据元素
  - end()游标是否到达尾部
- 函数原型
  - move(int i, int step = 1)
  - bool end()
  - T current()
  - bool next()
- 封装节点的申请和删除有利于增强扩展性

## 静态单链表

- 单链表的缺陷
- 触发条件
  - 长时间使用单链表对象频繁单增加和删除数据元素
- 可能的结果
  - 堆空间产生大量内存碎片，系统运行缓慢
- 新的线性表
  - 设计思路
  - 在单链表内部增加一片预留的空间，所有的Node对象都在这里面进行动态的创建和销毁。
  - 顺序表 + 单链表 = 静态单链表
- 静态单链表的实现思路
  - 通过模板定义静态单链表
  - 在类中定义固定的大小空间
  - 重写create和destory函数
  - 在Node类中重载operator new，用于在指定内存上创建对象